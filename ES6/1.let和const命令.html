<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>let和const命令</title>
</head>
<body>

<script>
    //1. let声明的变量只在let命令所在的代码块内有效
    {
        let a = 10;
        var b = 20;
    }
    //  console.log(a);  报错
    console.log(b);

    //2. for循环的计数器，很适合使用let命令
    for (let i = 1; i < 5; i++ ){
        console.log(i);
    }

    // console.log(i); 报错


    //3. 不存在变量提升
    //var 变量情况
    console.log(foo);  // 在变量声明前也可以调用， 输出undefined
    var foo = 2;

    //let 变量情况
   // console.log(bar);  // 报错 ： bar is not defined
    let bar = 2;

    //4. 暂时性死区
    var tmp = 123;

    if (true){
      //  tmp = "abv" ;   ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
        let  tmp;
    }

    //function bar1(x = y, y = 2) {
   //     return [x, y];
   // }

  //  bar1(); // 报错

    //5. 不允许重复声明

   // let不允许在相同作用域内，重复声明同一个变量。



    // ES6 的块级作用域 § ⇧

    {{{{{let insane = 'Hello World'}}}}};

    //上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。

    {{{{
        {let insane = 'Hello World'}
      //  console.log(insane); // 报错
    }}}};



//-------------------------------------- Const --------------------------------------------

    //1. const声明一个只读的常量。一旦声明，常量的值就不能改变
    const  a = 10;
  //  a = 20;  报错

    //2. 一旦声明，必须立即赋值


    //3. const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
    const  people = {};
    people.prop = 123;
    people.name = "aqva";
    console.log(people);

    //
    const  array = [];
    array.push('Hello');
    array.length = 0;
   // array = ['aaa'];   //报错
    

    var  b = 10000;
    console.log(window.b);



</script>

</body>



</html>